using './main.bicep'

// Minimal: Private Container Apps + Public Application Gateway
// - Creates a new VNet + subnets
// - Creates an INTERNAL Container Apps Environment (no public ingress)
// - Deploys a single hello-world Container App (internal ingress)
// - Deploys an Application Gateway with a Public IP to expose the app to the internet
// - Uses an auto-generated self-signed certificate for HTTPS (expect browser warning)
//
// Note on DNS:
// This scenario does NOT require you to own a DNS zone.
// The Application Gateway Public IP can have an Azure-managed DNS name:
//   <dnsLabel>.<region>.cloudapp.azure.com
// This is practical for testing because Azure provisions it automatically.

param deployToggles = {
  // Observability (required by this template path for Container Apps Environment)
  logAnalytics: true
  appInsights: true

  // Networking
  virtualNetwork: true
  peNsg: false
  agentNsg: false
  acaEnvironmentNsg: true
  applicationGatewayNsg: true

  // Key Vault not required for the self-signed lab path (PFX is uploaded directly to App Gateway).
  // Enable only if you plan to use `appGatewayDefinition.httpsKeyVaultSecretId` (pre-created certificate in KV).
  keyVault: false

  // Container platform
  containerEnv: true
  containerApps: true

  // Application Gateway
  applicationGateway: true
  applicationGatewayPublicIp: true

  // Keep simple: no WAF policy, no APIM
  wafPolicy: false
  apiManagement: false
  apiManagementNsg: false
  
  // Test VM access (via Bastion)
  jumpVm: true
  jumpboxNsg: true
  bastionHost: true
  bastionNsg: true
  devopsBuildAgentsNsg: false
  buildVm: false
  appConfig: false
  storageAccount: false
  cosmosDb: false
  searchService: false
  containerRegistry: false
  groundingWithBingSearch: false
  aiFoundry: false
  
  // Egress controls (forced tunneling via Azure Firewall)
  firewall: true
  userDefinedRoutes: true
}

param resourceIds = {
}

param flagPlatformLandingZone = false

// Forced tunneling: route 0.0.0.0/0 from workload subnets to Azure Firewall.
// App Gateway v2 requires internet routing for management, so we enable the exception.
// (Configured under appGatewayDefinition.appGatewayInternetRoutingException)

// Required for UDR forced tunneling: Azure Firewall private IP (next hop).
// With the default subnet layout, Azure Firewall is assigned the first usable IP in AzureFirewallSubnet (192.168.0.128/26) => 192.168.0.132.
param firewallPrivateIp = '192.168.0.132'

// Application Gateway defaults:
// - Public IP DNS label defaults to the Public IP resource name (pip-agw-<baseName>)
// - HTTPS listener (443) uses a self-signed PFX auto-generated by the template and uploaded directly to App Gateway
param appGatewayDefinition = {
  // Keep it minimal: avoid WAF_v2 (and WAF policy) for this testing scenario.
  sku: 'Standard_v2'

  enableHttps: true
  createSelfSignedCertificate: true

  // Forced tunneling exception for AppGW v2 management traffic
  appGatewayInternetRoutingException: true

  // Self-signed lab path (no Key Vault): the template auto-generates a PFX + random password
  // and uploads it directly to Application Gateway.
}

// Minimal egress allow policy for forced tunneling.
// This is intentionally permissive for a test environment.
param firewallPolicyDefinition = {
  name: 'afwp-appgw-min'
  ruleCollectionGroups: [
    {
      name: 'rcg-allow-egress'
      priority: 100
      ruleCollections: [
        {
          name: 'rc-allow-jumpbox-any'
          priority: 100
          ruleCollectionType: 'FirewallPolicyFilterRuleCollection'
          action: {
            type: 'Allow'
          }
          rules: [
            {
              name: 'allow-jumpbox-all-egress'
              ruleType: 'NetworkRule'
              ipProtocols: [
                'Any'
              ]
              sourceAddresses: [
                '192.168.1.64/28' // jumpbox-subnet
              ]
              destinationAddresses: [
                '0.0.0.0/0'
              ]
              destinationPorts: [
                '*'
              ]
            }
          ]
        }
        {
          name: 'rc-allow-aca-any'
          priority: 110
          ruleCollectionType: 'FirewallPolicyFilterRuleCollection'
          action: {
            type: 'Allow'
          }
          rules: [
            {
              name: 'allow-aca-all-egress'
              ruleType: 'NetworkRule'
              ipProtocols: [
                'Any'
              ]
              sourceAddresses: [
                '192.168.1.0/27' // aca-env-subnet
              ]
              destinationAddresses: [
                '0.0.0.0/0'
              ]
              destinationPorts: [
                '*'
              ]
            }
          ]
        }
      ]
    }
  ]
}

param containerAppEnvDefinition = {
  name: 'cae-appgw-min'

  // Internal-only environment endpoints.
  internal: true
  publicNetworkAccess: 'Disabled'
  zoneRedundant: false
}

param containerAppsList = [
  {
    name: 'ca-hello'

    // Only apps explicitly flagged are added to the App Gateway backend pool.
    exposeViaAppGateway: true

    activeRevisionsMode: 'Single'

    // VNet-reachable ingress (Application Gateway / jump VM can reach it).
    // Note: because the Container Apps Environment is internal + publicNetworkAccess is Disabled,
    // this does NOT expose the app to the public internet.
    ingressExternal: true
    ingressTargetPort: 80
    ingressAllowInsecure: true
  }
]

// Tip:
// After provisioning, get the Application Gateway public endpoint and test:
// - https://<pip-dns>.<region>.cloudapp.azure.com/  (browser warning is expected with self-signed cert)
